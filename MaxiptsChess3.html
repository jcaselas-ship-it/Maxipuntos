<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Maxipuntos Chess</title>
    <!-- Carga de Font Awesome para los iconos de las piezas y el icono de ayuda -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/all.min.css">
    <!-- Carga de Tailwind CSS para el estilo -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- React CDN -->
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <!-- Babel CDN for JSX transpilation -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <!-- Configuración para usar la fuente Inter -->
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    fontFamily: {
                        sans: ['Inter', 'sans-serif'],
                    },
                    colors: {
                        'board-light': '#eab308', 
                        'board-dark': '#3b82f6',
                        'safe-cell': 'rgba(52, 211, 153, 0.7)',
                        'unplayable': 'rgba(251, 191, 36, 0.5)',
                        'piece-white': '#ffffff', 
                    }
                }
            }
        }
    </script>
    <style>
        body {
            overscroll-behavior: none;
        }
        /* Estilos para los iconos de Font Awesome */
        .piece i {
            font-size: 2.5rem; /* Tamaño grande para el tablero */
            display: block; 
            filter: none;
            line-height: 1;
            user-select: none;
        }

        /* Colores de las piezas */
        .enemy-piece {
            color: #1e293b; /* slate-800 */
            filter: drop-shadow(0 0 3px rgba(255, 255, 255, 0.6)); 
        }

        .friendly-piece {
            color: #ffffff; 
            filter: drop-shadow(0 0 5px rgba(0, 0, 0, 1)) drop-shadow(0 0 1px rgba(255, 255, 255, 0.5));
        }
        
        /* Asegurar que el tablero sea cuadrado */
        #chessboard-container {
            width: 95vw;
            max-width: 500px;
            margin: 1rem auto;
            aspect-ratio: 1 / 1; 
        }
        
        /* Estilo para el drag-over visual en el tablero */
        .drag-hover {
            outline: 3px solid #fcd34d; /* Amber-400 */
            background-color: #fcd34d66 !important;
        }

        /* Animación para el parpadeo de la pieza colocada */
        @keyframes flash-3x {
            0%, 100% { opacity: 1; }
            25%, 75% { opacity: 0.2; }
            50% { opacity: 1; }
        }

        .flashing-piece {
            animation: flash-3x 0.5s ease-in-out 3; 
        }

        /* RESALTE PERMANENTE DE LA ÚLTIMA JUGADA */
        .last-move {
            outline: 3px solid #818cf8; /* indigo-400 */
            box-shadow: 0 0 10px rgba(129, 140, 248, 0.7);
            z-index: 10;
        }
    </style>
</head>
<body class="bg-gray-100 p-4 font-sans text-gray-800">
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useMemo, useCallback, useEffect, StrictMode, memo } = React;

        // --- START OF constants.js ---
        const PIECE_VALUES = {
          'P': 1, 'N': 3, 'B': 3, 'R': 5, 'Q': 9, // White
          'p': 1, 'n': 3, 'b': 2, 'r': 5, 'q': 9  // Black - Black Rook ('r') is now 5 points
        };

        const PIECE_TYPE_CLASSES = {
          'P': 'fa-chess-pawn', 'N': 'fa-chess-knight', 'B': 'fa-chess-bishop',
          'R': 'fa-chess-rook', 'Q': 'fa-chess-queen', 'K': 'fa-chess-king'
        };

        const INITIAL_STOCK = {
          'P': 8, 'N': 2, 'B': 2, 'R': 2, 'Q': 1, // White
          'p': 8, 'n': 2, 'b': 2, 'r': 2, 'q': 1  // Black
        };

        const SCORE_MILESTONES = [
          { score: 50, message: "¡CAMPEÓN/A! ¡Puntuación al Nivel Más Alto!", title: "¡LEYENDA!" },
          { score: 45, message: "¡Nivel Superior! Estás en la élite.", title: "¡MAGNÍFICO!" },
          { score: 40, message: "¡Cerca del Récord! Sigue así, el techo está cerca.", title: "¡IMPRESIONANTE!" },
          { score: 35, message: "¡Muy Bien! Ya superaste la media.", title: "¡EXCELENTE!" },
          { score: 30, message: "¡Vas Bien! Ya tienes una puntuación sólida.", title: "¡BUEN INICIO!" }
        ];

        const PIECE_ORDER = ['Q', 'R', 'B', 'N', 'P'];
        // --- END OF constants.js ---

        // --- START OF services/audioService.js ---
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();

        const playSound = (type, frequency, duration, startGain) => {
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();

            oscillator.type = type;
            oscillator.frequency.setValueAtTime(frequency, audioContext.currentTime);
            gainNode.gain.setValueAtTime(0, audioContext.currentTime);
            gainNode.gain.linearRampToValueAtTime(startGain, audioContext.currentTime + 0.05);
            gainNode.gain.linearRampToValueAtTime(0, audioContext.currentTime + duration);

            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);

            oscillator.start(audioContext.currentTime);
            oscillator.stop(audioContext.currentTime + duration);
        }

        const playSuccessSound = (isMuted) => {
            if (isMuted) return;
            playSound('sine', 440, 0.3, 0.5);
        };

        const playErrorSound = (isMuted) => {
            if (isMuted) return;
            playSound('sawtooth', 120, 0.2, 0.5);
        };

        const playFanfare = (isMuted) => {
            if (isMuted) return;

            const now = audioContext.currentTime;
            
            // Note 1
            const osc1 = audioContext.createOscillator();
            const gain1 = audioContext.createGain();
            osc1.type = 'square';
            osc1.frequency.setValueAtTime(660, now); // E5
            gain1.gain.setValueAtTime(0, now);
            gain1.gain.linearRampToValueAtTime(0.7, now + 0.05);
            gain1.gain.exponentialRampToValueAtTime(0.001, now + 1.0);
            osc1.connect(gain1).connect(audioContext.destination);
            osc1.start(now);
            osc1.stop(now + 1.0);

            // Note 2
            const osc2 = audioContext.createOscillator();
            const gain2 = audioContext.createGain();
            osc2.type = 'sine';
            osc2.frequency.setValueAtTime(880, now + 0.2); // A5
            gain2.gain.setValueAtTime(0, now + 0.2);
            gain2.gain.linearRampToValueAtTime(0.5, now + 0.25);
            gain2.gain.exponentialRampToValueAtTime(0.001, now + 1.2);
            osc2.connect(gain2).connect(audioContext.destination);
            osc2.start(now + 0.2);
            osc2.stop(now + 1.2);
        };
        // --- END OF services/audioService.js ---

        // --- START OF hooks/useGameLogic.js ---
        const createEmptyBoard = () => Array(8).fill(null).map(() => Array(8).fill(null));

        const getStraightAttacks = (r, c, board) => {
            const attacks = [];
            const directions = [[0, 1], [0, -1], [1, 0], [-1, 0]];
            for (const [dr, dc] of directions) {
                let [cr, cc] = [r + dr, c + dc];
                while (cr >= 0 && cr < 8 && cc >= 0 && cc < 8) {
                    attacks.push([cr, cc]);
                    if (board[cr][cc]) break;
                    [cr, cc] = [cr + dr, cc + dc];
                }
            }
            return attacks;
        };

        const getDiagonalAttacks = (r, c, board) => {
            const attacks = [];
            const directions = [[1, 1], [1, -1], [-1, 1], [-1, -1]];
            for (const [dr, dc] of directions) {
                let [cr, cc] = [r + dr, c + dc];
                while (cr >= 0 && cr < 8 && cc >= 0 && cc < 8) {
                    attacks.push([cr, cc]);
                    if (board[cr][cc]) break;
                    [cr, cc] = [cr + dr, cc + dc];
                }
            }
            return attacks;
        };

        const getKnightAttacks = (r, c) => {
            const attacks = [];
            const moves = [[2, 1], [2, -1], [-2, 1], [-2, -1], [1, 2], [1, -2], [-1, 2], [-1, -2]];
            for (const [dr, dc] of moves) {
                const [tr, tc] = [r + dr, c + dc];
                if (tr >= 0 && tr < 8 && tc >= 0 && tc < 8) {
                    attacks.push([tr, tc]);
                }
            }
            return attacks;
        };

        const getPawnAttacks = (r, c, isWhite) => {
            const attacks = [];
            const dir = isWhite ? -1 : 1;
            const moves = [[dir, -1], [dir, 1]];
            for (const [dr, dc] of moves) {
                const [tr, tc] = [r + dr, c + dc];
                if (tr >= 0 && tr < 8 && tc >= 0 && tc < 8) {
                    attacks.push([tr, tc]);
                }
            }
            return attacks;
        };

        const calculatePieceAttacks = (piece, r, c, currentBoard) => {
            const pieceType = piece.toUpperCase();
            const isWhite = piece === pieceType;
            switch (pieceType) {
                case 'R': return getStraightAttacks(r, c, currentBoard);
                case 'B': return getDiagonalAttacks(r, c, currentBoard);
                case 'Q': return [...getStraightAttacks(r, c, currentBoard), ...getDiagonalAttacks(r, c, currentBoard)];
                case 'N': return getKnightAttacks(r, c);
                case 'P': return getPawnAttacks(r, c, isWhite);
                default: return [];
            }
        };

        const checkNewThreats = (r, c, piece, currentBoard) => {
            const attacks = calculatePieceAttacks(piece, r, c, currentBoard);
            for (const [ar, ac] of attacks) {
                if (currentBoard[ar][ac] !== null) {
                    return true;
                }
            }
            return false;
        };

        const useGameLogic = () => {
            const [board, setBoard] = useState(createEmptyBoard());
            const [score, setScore] = useState(0);
            const [remainingStock, setRemainingStock] = useState({ ...INITIAL_STOCK });
            const [history, setHistory] = useState([]);
            const [showThreats, setShowThreats] = useState(false);
            const [isMuted, setIsMuted] = useState(true);
            const [gameActive, setGameActive] = useState(true);
            const [lastPlacedPiece, setLastPlacedPiece] = useState(null);
            const [modalContent, setModalContent] = useState(null);
            const [achievedMilestones, setAchievedMilestones] = useState(new Set());
            const [errorCell, setErrorCell] = useState(null);
            const [flashingPiece, setFlashingPiece] = useState(null);

            const threatMap = useMemo(() => {
                let newThreatMap = Array(8).fill(null).map(() => Array(8).fill(0));
                for (let r = 0; r < 8; r++) {
                    for (let c = 0; c < 8; c++) {
                        const piece = board[r][c];
                        if (piece) {
                            const attacks = calculatePieceAttacks(piece, r, c, board);
                            for (const [ar, ac] of attacks) {
                                newThreatMap[ar][ac] = 1;
                            }
                        }
                    }
                }
                return newThreatMap;
            }, [board]);

            const checkGameOver = useCallback(() => {
                let totalRemainingPieces = Object.values(remainingStock).reduce((sum, count) => sum + count, 0);
                let safeSquaresExist = false;
                let emptySquaresExist = false;
                
                for(let r = 0; r < 8; r++) {
                    for(let c = 0; c < 8; c++) {
                        if (board[r][c] === null) {
                            emptySquaresExist = true;
                            if(threatMap[r][c] === 0) {
                                safeSquaresExist = true;
                            }
                        }
                    }
                }

                let gameOverReason = null;
                if (totalRemainingPieces === 0) gameOverReason = `¡Juego Terminado! Has usado todas tus piezas. Puntuación final: ${score}`;
                else if (!safeSquaresExist && emptySquaresExist) gameOverReason = `¡Juego Terminado! No quedan casillas vacías y seguras para colocar. Puntuación final: ${score}`;
                else if (!emptySquaresExist) gameOverReason = `¡Juego Terminado! El tablero está lleno. Puntuación final: ${score}`;

                if (gameOverReason) {
                    setGameActive(false);
                    if (score < 30) {
                        setModalContent({ title: "Juego Terminado", message: gameOverReason });
                    }
                }
            }, [remainingStock, board, threatMap, score]);
            
            useEffect(() => {
                if(gameActive) {
                    checkGameOver();
                }
            }, [board, gameActive, checkGameOver]);

            const saveState = (r, c) => {
                const state = {
                    board: board.map(row => [...row]),
                    score: score,
                    remainingStock: { ...remainingStock },
                    lastPieceCoords: [r, c]
                };
                setHistory(prev => [...prev, state].slice(-20));
            };

            const placePiece = (r, c, piece) => {
                saveState(r,c);

                const newBoard = board.map(row => [...row]);
                newBoard[r][c] = piece;
                setBoard(newBoard);

                const newScore = score + PIECE_VALUES[piece];
                setScore(newScore);

                const newStock = { ...remainingStock };
                newStock[piece]--;
                setRemainingStock(newStock);

                setLastPlacedPiece(piece);
                playSuccessSound(isMuted);

                setFlashingPiece([r, c]);
                setTimeout(() => setFlashingPiece(null), 1500);

                for (const { score: threshold, message, title } of SCORE_MILESTONES) {
                    if (newScore >= threshold && !achievedMilestones.has(threshold)) {
                        setAchievedMilestones(prev => new Set(prev).add(threshold));
                        setModalContent({ title, message: `${message}\\n\\n¡Puntuación Actual: ${newScore} puntos!` });
                        playFanfare(isMuted);
                        break;
                    }
                }
            };

            const handleSquareDrop = (r, c, piece) => {
                if (!gameActive || board[r][c] || remainingStock[piece] <= 0) {
                    playErrorSound(isMuted);
                    return;
                }

                if (threatMap[r][c] > 0 || checkNewThreats(r, c, piece, board)) {
                    playErrorSound(isMuted);
                    setErrorCell([r, c]);
                    setTimeout(() => setErrorCell(null), 500);
                    return;
                }

                placePiece(r, c, piece);
            };

            const resetGame = useCallback(() => {
                setBoard(createEmptyBoard());
                setScore(0);
                setRemainingStock({ ...INITIAL_STOCK });
                setHistory([]);
                setAchievedMilestones(new Set());
                setGameActive(true);
                setLastPlacedPiece(null);
                setModalContent(null);
            }, []);

            const undoMove = useCallback(() => {
                if (history.length === 0) {
                    playErrorSound(isMuted);
                    return;
                }

                const lastState = history[history.length - 1];
                const oldScore = lastState.score;

                const newHistory = history.slice(0, -1);
                setHistory(newHistory);

                if (newHistory.length > 0) {
                    const prevState = newHistory[newHistory.length - 1];
                    setBoard(prevState.board.map(row => [...row]));
                    setScore(prevState.score);
                    setRemainingStock({ ...prevState.remainingStock });
                    const [lr, lc] = prevState.lastPieceCoords;
                    setLastPlacedPiece(prevState.board[lr][lc]);
                } else {
                    resetGame();
                }

                setGameActive(true);
                const newAchieved = new Set(achievedMilestones);
                SCORE_MILESTONES.forEach(({ score: threshold }) => {
                    if (score < threshold && oldScore >= threshold) {
                        newAchieved.delete(threshold);
                    }
                });
                setAchievedMilestones(newAchieved);

            }, [history, isMuted, resetGame, score, achievedMilestones]);
            
            const toggleThreats = useCallback(() => setShowThreats(s => !s), []);
            const toggleSound = useCallback(() => {
                setIsMuted(m => {
                    if (m) playSuccessSound(false);
                    return !m;
                });
            }, []);
            const closeModal = useCallback(() => setModalContent(null), []);
            const showHelp = useCallback(() => {
                setModalContent({
                    title: "¿Cómo jugar? (Maxipuntos)",
                    message: "**Arrastra y coloca piezas** sin que **ninguna ataque a otra** para sumar el mayor número de puntos. Pulsa el botón del **'ojo'** para visualizar las casillas amenazadas (color ámbar)."
                });
            }, []);

            return {
                board, score, remainingStock, gameActive, showThreats, isMuted,
                lastPlacedPiece, modalContent, threatMap, errorCell, flashingPiece,
                lastMoveCoords: history.length > 0 ? history[history.length - 1].lastPieceCoords : null,
                canUndo: history.length > 0,
                handleSquareDrop, resetGame, undoMove, toggleThreats, toggleSound, showHelp, closeModal,
                setDraggedPiece: setLastPlacedPiece
            };
        };
        // --- END OF hooks/useGameLogic.js ---

        // --- START OF components ---
        const PieceIcon = memo(({ piece }) => {
            const pieceType = piece.toUpperCase();
            const faClass = PIECE_TYPE_CLASSES[pieceType] || '';
            const isWhite = piece === pieceType;
            const colorClass = isWhite ? 'friendly-piece' : 'enemy-piece';

            return <i className={`fas ${faClass} ${colorClass}`}></i>;
        });

        const Modal = ({ content, onClose }) => {
            if (!content) {
                return null;
            }
            
            const handleBackdropClick = (e) => {
                if (e.target === e.currentTarget) {
                    onClose();
                }
            };

            return (
                <div
                    className="fixed inset-0 bg-gray-900 bg-opacity-75 flex items-center justify-center z-50 p-4"
                    onClick={handleBackdropClick}
                >
                    <div
                        className="bg-white rounded-xl p-6 max-w-sm w-full shadow-2xl transition-all duration-300 ease-out transform scale-95 opacity-0 animate-modal-enter"
                        role="dialog"
                        aria-modal="true"
                        style={{ animation: 'modal-enter 0.3s ease-out forwards' }}
                    >
                        <h3 className="text-xl font-bold mb-3 text-indigo-700">{content.title}</h3>
                        <p className="text-gray-700 mb-6 whitespace-pre-wrap" dangerouslySetInnerHTML={{ __html: content.message.replace(/\\*\\*(.*?)\\*\\*/g, '<strong>$1</strong>') }}></p>
                        <button
                            onClick={onClose}
                            className="w-full bg-indigo-600 text-white py-2 rounded-lg font-semibold hover:bg-indigo-700 transition"
                        >
                            Entendido
                        </button>
                    </div>
                    <style>{`
                        @keyframes modal-enter {
                            to {
                                transform: scale(1);
                                opacity: 1;
                            }
                        }
                    `}</style>
                </div>
            );
        };
        
        const LastPlacedPieceDisplay = memo(({ piece }) => {
            const baseClasses = "inline-flex items-center justify-center py-2 px-4 rounded-lg font-bold text-xl shadow w-40 h-16 transition-all duration-300";

            if (!piece) {
                return (
                    <div className={`${baseClasses} bg-gray-100 text-gray-700`}>
                        <span className="text-center text-sm">Arrastra una pieza</span>
                    </div>
                );
            }

            const isWhitePiece = piece === piece.toUpperCase();
            const markerStyleClasses = isWhitePiece
                ? 'bg-white border-2 border-indigo-600'
                : 'bg-white border-2 border-gray-900';

            return (
                <div className={`${baseClasses} ${markerStyleClasses}`}>
                    <div className="text-5xl flex items-center justify-center h-full w-full">
                        <PieceIcon piece={piece} />
                    </div>
                </div>
            );
        });

        const Header = memo(({ score, lastPlacedPiece, onHelpClick }) => {
            return (
                <div className="flex flex-wrap justify-center sm:justify-between items-center mb-4 p-3 bg-white rounded-xl shadow-lg">
                    <div className="mb-4 sm:mb-0 text-center sm:text-left order-1 w-40">
                        <p className="text-sm font-semibold text-gray-500">Puntuación Total:</p>
                        <div className="inline-flex items-center justify-center bg-indigo-100 text-indigo-700 py-2 px-4 rounded-lg font-bold shadow h-16 w-40">
                            <p className="text-5xl font-bold">{score}</p>
                        </div>
                    </div>
                    <button
                        onClick={onHelpClick}
                        className="flex flex-col items-center justify-center h-16 w-16 my-2 sm:my-0 bg-yellow-400 hover:bg-yellow-500 rounded-full shadow-lg transition duration-150 transform hover:scale-105 order-2"
                        title="¿Cómo jugar?"
                    >
                        <i className="fas fa-question text-3xl text-gray-800"></i>
                    </button>
                    <div className="text-center sm:text-right order-3 w-40">
                        <p className="text-sm font-semibold text-gray-500">Última Pieza Colocada:</p>
                        <LastPlacedPieceDisplay piece={lastPlacedPiece} />
                    </div>
                </div>
            );
        });

        const ControlButton = ({ onClick, disabled = false, title, className, children }) => {
            return (
                <button
                    onClick={onClick}
                    disabled={disabled}
                    className={`p-2 rounded-lg font-bold shadow transition duration-150 w-full text-white ${className} ${disabled ? 'opacity-50 cursor-not-allowed' : ''}`}
                    title={title}
                >
                    {children}
                </button>
            );
        };

        const Controls = memo(({ showThreats, isMuted, canUndo, onToggleThreats, onToggleSound, onUndo, onReset }) => {
            return (
                <div className="max-w-xl mx-auto mb-4 grid grid-cols-2 sm:grid-cols-4 gap-4">
                    <ControlButton
                        onClick={onToggleThreats}
                        title="Alternar Resalte de Amenazas (Ámbar)"
                        className={showThreats ? 'bg-green-600 hover:bg-green-700' : 'bg-pink-600 hover:bg-pink-700'}
                    >
                        <i className={`fas ${showThreats ? 'fa-eye-slash' : 'fa-eye'}`}></i>
                    </ControlButton>
                    <ControlButton
                        onClick={onToggleSound}
                        title="Activar/Desactivar Sonido"
                        className={isMuted ? 'bg-gray-500 hover:bg-gray-600' : 'bg-blue-600 hover:bg-blue-700'}
                    >
                        <i className={`fas ${isMuted ? 'fa-volume-mute' : 'fa-volume-up'}`}></i>
                    </ControlButton>
                    <ControlButton
                        onClick={onUndo}
                        disabled={!canUndo}
                        title="Deshacer el último movimiento"
                        className="bg-yellow-600 hover:bg-yellow-700"
                    >
                        <i className="fas fa-undo"></i>
                    </ControlButton>
                    <ControlButton
                        onClick={onReset}
                        title="Reiniciar el juego"
                        className="bg-red-600 hover:bg-red-700"
                    >
                        <i className="fas fa-redo"></i>
                    </ControlButton>
                </div>
            );
        });

        const StockPiece = ({ piece, count, gameActive, setDraggedPiece }) => {
            const isDraggable = count > 0 && gameActive;
            
            const handleDragStart = (e) => {
                if (!isDraggable) return;
                e.dataTransfer.setData('text/plain', piece);
                e.dataTransfer.effectAllowed = 'copy';
                setDraggedPiece(piece);
            };
            
            const handleDragEnd = () => {
                setDraggedPiece(null);
            }

            const containerClasses = `
                stock-piece flex flex-col items-center p-1 rounded-lg transition duration-150 
                ${isDraggable ? 'bg-gray-100 hover:bg-gray-300 cursor-grab shadow-sm' : 'bg-gray-300 opacity-50 cursor-not-allowed'}
            `;

            return (
                <div
                    className={containerClasses}
                    draggable={isDraggable}
                    onDragStart={handleDragStart}
                    onDragEnd={handleDragEnd}
                >
                    <div className="text-3xl">
                        <PieceIcon piece={piece} />
                    </div>
                    <span className="text-sm font-semibold mt-1">{count}</span>
                </div>
            );
        };

        const Stock = memo(({ color, stock, gameActive, setDraggedPiece }) => {
            const isBlack = color === 'black';
            const containerId = isBlack ? 'stock-black-container' : 'stock-white-container';
            const orderClass = isBlack ? 'order-3 lg:order-1' : 'order-2 lg:order-3';

            const getPieceForColor = (type) => {
                return isBlack ? type.toLowerCase() : type.toUpperCase();
            };
            
            return (
                <div id={containerId} className={`${orderClass} p-2 bg-white rounded-xl shadow-lg flex flex-row lg:flex-col justify-center gap-2 w-full lg:w-24 m-2 lg:m-0`}>
                    <h3 className={`text-md font-bold text-center lg:mb-1 border-b lg:border-b-0 ${isBlack ? 'text-gray-700' : 'text-gray-900'}`}>
                        {isBlack ? 'Negras' : 'Blancas'}
                    </h3>
                    <div id={`remaining-pieces-${color}`} className="flex flex-row lg:flex-col gap-x-2 gap-y-2 justify-center lg:gap-y-4">
                        {PIECE_ORDER.map(type => {
                            const piece = getPieceForColor(type);
                            return <StockPiece key={piece} piece={piece} count={stock[piece]} gameActive={gameActive} setDraggedPiece={setDraggedPiece} />;
                        })}
                    </div>
                </div>
            );
        });

        const Square = memo(({ r, c, content, isThreatened, showThreats, isError, isFlashing, isLastMove, gameActive, onDragOver, onDragLeave, onDrop }) => {
            const isLight = (r + c) % 2 === 0;
            let bgColor = isLight ? 'bg-board-light' : 'bg-board-dark';

            if (isError) {
                bgColor = 'bg-red-500 animate-pulse';
            } else if (showThreats) {
                if (isThreatened) {
                    bgColor = 'bg-unplayable';
                } else if (!content) {
                    bgColor = 'bg-safe-cell';
                }
            } else if (!content && gameActive) {
                bgColor += isLight ? ' hover:bg-yellow-700' : ' hover:bg-blue-600';
            }
            
            const handleDragOver = (e) => onDragOver(e, r, c);
            const handleDragLeave = (e) => onDragLeave(e);
            const handleDrop = (e) => onDrop(e, r, c);

            return (
                <div
                    className={`square w-[12.5%] h-[12.5%] flex items-center justify-center relative transition-colors duration-200 ${bgColor} ${isLastMove ? 'last-move' : ''}`}
                    data-row={r}
                    data-col={c}
                    onDragOver={handleDragOver}
                    onDragLeave={handleDragLeave}
                    onDrop={handleDrop}
                >
                    {content && (
                        <div className={`piece transform transition-transform duration-100 hover:scale-105 ${isFlashing ? 'flashing-piece' : ''}`}>
                            <PieceIcon piece={content} />
                        </div>
                    )}
                </div>
            );
        });

        const Chessboard = ({ board, threatMap, showThreats, gameActive, errorCell, flashingPiece, lastMoveCoords, onDrop }) => {
            const handleDragOver = (e, r, c) => {
                e.preventDefault();
                if (gameActive && !board[r][c] && threatMap[r][c] === 0) {
                    e.target.closest('.square')?.classList.add('drag-hover');
                }
            };

            const handleDragLeave = (e) => {
                e.target.closest('.square')?.classList.remove('drag-hover');
            };
            
            const handleDrop = (e, r, c) => {
                e.preventDefault();
                e.target.closest('.square')?.classList.remove('drag-hover');
                const piece = e.dataTransfer.getData('text/plain');
                if (piece) {
                    onDrop(r, c, piece);
                }
            };
            
            return (
                <div id="chessboard" className="w-full h-full flex flex-wrap">
                    {board.map((row, r) =>
                        row.map((content, c) => (
                            <Square
                                key={`${r}-${c}`}
                                r={r}
                                c={c}
                                content={content}
                                isThreatened={threatMap[r][c] > 0}
                                showThreats={showThreats}
                                isError={!!(errorCell && errorCell[0] === r && errorCell[1] === c)}
                                isFlashing={!!(flashingPiece && flashingPiece[0] === r && flashingPiece[1] === c)}
                                isLastMove={!!(lastMoveCoords && lastMoveCoords[0] === r && lastMoveCoords[1] === c)}
                                gameActive={gameActive}
                                onDragOver={handleDragOver}
                                onDragLeave={handleDragLeave}
                                onDrop={handleDrop}
                            />
                        ))
                    )}
                </div>
            );
        };
        // --- END OF components ---

        // --- START OF App.jsx ---
        function App() {
            const {
                board, score, remainingStock, gameActive, showThreats, isMuted,
                lastPlacedPiece, modalContent, threatMap, errorCell, flashingPiece,
                lastMoveCoords, canUndo, handleSquareDrop, resetGame, undoMove,
                toggleThreats, toggleSound, showHelp, closeModal, setDraggedPiece
            } = useGameLogic();

            return (
                <React.Fragment>
                    <div className="max-w-xl mx-auto">
                        <h1 className="text-3xl font-extrabold text-center mb-3 text-gray-900">Maxipuntos Chess</h1>
                        <Header score={score} lastPlacedPiece={lastPlacedPiece} onHelpClick={showHelp} />
                        <Controls
                            showThreats={showThreats}
                            isMuted={isMuted}
                            canUndo={canUndo}
                            onToggleThreats={toggleThreats}
                            onToggleSound={toggleSound}
                            onUndo={undoMove}
                            onReset={resetGame}
                        />
                    </div>

                    <div id="game-layout" className="max-w-4xl mx-auto flex flex-col lg:flex-row lg:justify-center lg:items-start gap-1 lg:gap-0 mt-4">
                        <Stock
                            color="black"
                            stock={remainingStock}
                            gameActive={gameActive}
                            setDraggedPiece={setDraggedPiece}
                        />

                        <div id="chessboard-container" className="order-1 lg:order-2 shadow-lg rounded-lg overflow-hidden">
                            <Chessboard
                                board={board}
                                threatMap={threatMap}
                                showThreats={showThreats}
                                gameActive={gameActive}
                                errorCell={errorCell}
                                flashingPiece={flashingPiece}
                                lastMoveCoords={lastMoveCoords}
                                onDrop={handleSquareDrop}
                            />
                        </div>

                        <Stock
                            color="white"
                            stock={remainingStock}
                            gameActive={gameActive}
                            setDraggedPiece={setDraggedPiece}
                        />
                    </div>
                    
                    <Modal
                        content={modalContent}
                        onClose={closeModal}
                    />
                </React.Fragment>
            );
        }
        // --- END OF App.jsx ---

        // --- START OF index.jsx ---
        const rootElement = document.getElementById('root');
        if (rootElement) {
            const root = ReactDOM.createRoot(rootElement);
            root.render(
              <StrictMode>
                <App />
              </StrictMode>
            );
        }
        // --- END OF index.jsx ---

    </script>
</body>
</html>
